<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Soobi Runner - Procedural Edition</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body { margin: 0; padding: 0; background: #fff; }
    canvas { display: block; margin: 0 auto; }
  </style>
</head>
<body>
<script>
// Phaser configuration â€“ using only black & white.
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 200,
    backgroundColor: '#fff',
    physics: {
        default: 'arcade',
        arcade: { gravity: { y: 1200 }, debug: false }
    },
    scene: { preload: preload, create: create, update: update }
};

let game = new Phaser.Game(config);
let soobi, ground, obstacles, treats;
let score = 0;
let scoreText, messageText;
let gameOver = false;
let cursors;
let confettiEmitter;

function preload() {
  // --- Create a minimal background ---
  // We keep the background plain white and draw a thin ground line later.
  // (No texture needed for the sky.)

  // --- Create a detailed dog silhouette ---
  // We generate two frames for a running animation.
  let dogGraphics = this.make.graphics({ add: false });
  
  // Frame 1: Draw a dog silhouette with a body, head, ear, and tail.
  dogGraphics.fillStyle(0x000000, 1);
  // Draw body (rectangle)
  dogGraphics.fillRect(10, 20, 30, 20);
  // Draw head (circle)
  dogGraphics.fillCircle(48, 30, 8);
  // Draw ear (triangle)
  dogGraphics.beginPath();
  dogGraphics.moveTo(45, 20);
  dogGraphics.lineTo(50, 10);
  dogGraphics.lineTo(55, 20);
  dogGraphics.closePath();
  dogGraphics.fillPath();
  // Draw tail (a small rectangle on left)
  dogGraphics.fillRect(0, 28, 10, 4);
  dogGraphics.generateTexture('dog1', 60, 50);
  dogGraphics.clear();
  
  // Frame 2: Slight variation (head lowered a bit) for animation.
  dogGraphics.fillStyle(0x000000, 1);
  dogGraphics.fillRect(10, 20, 30, 20);          // body
  dogGraphics.fillCircle(48, 32, 8);               // head shifted down
  dogGraphics.beginPath();                         // ear remains the same
  dogGraphics.moveTo(45, 20);
  dogGraphics.lineTo(50, 10);
  dogGraphics.lineTo(55, 20);
  dogGraphics.closePath();
  dogGraphics.fillPath();
  dogGraphics.fillRect(0, 28, 10, 4);              // tail
  dogGraphics.generateTexture('dog2', 60, 50);
  dogGraphics.destroy();

  // --- Create a hurdle obstacle texture ---
  let hurdleGraphics = this.make.graphics({ add: false });
  hurdleGraphics.fillStyle(0x000000, 1);
  // Draw a base rectangle for the hurdle.
  hurdleGraphics.fillRect(0, 10, 30, 20);
  // Draw a curved top (simulate a semicircular top).
  hurdleGraphics.fillCircle(15, 10, 15);
  hurdleGraphics.generateTexture('hurdle', 30, 30);
  hurdleGraphics.destroy();

  // --- Create a confetti texture (a small square) ---
  let confettiGraphics = this.make.graphics({ add: false });
  confettiGraphics.fillStyle(0x000000, 1);
  confettiGraphics.fillRect(0, 0, 4, 4);
  confettiGraphics.generateTexture('confetti', 4, 4);
  confettiGraphics.destroy();
}

function create() {
  // --- Create the ground (a thin black line) ---
  ground = this.add.rectangle(400, 150, 800, 5, 0x000000);
  this.physics.add.existing(ground, true);
  
  // --- Create the animated dog (Soobi) ---
  soobi = this.physics.add.sprite(50, 100, 'dog1');
  soobi.setCollideWorldBounds(true);
  soobi.body.setSize(60, 50);
  soobi.setGravityY(1200);
  this.anims.create({
    key: 'run',
    frames: [
      { key: 'dog1' },
      { key: 'dog2' }
    ],
    frameRate: 8,
    repeat: -1
  });
  soobi.anims.play('run', true);
  this.physics.add.collider(soobi, ground);
  
  // --- Create groups for obstacles (hurdles) and treats ---
  obstacles = this.physics.add.group();
  treats = this.physics.add.group();
  
  // Spawn hurdles every 2000ms (easy pacing).
  this.time.addEvent({
    delay: 2000,
    callback: spawnObstacle,
    callbackScope: this,
    loop: true
  });
  
  // Spawn treats every 3000ms.
  this.time.addEvent({
    delay: 3000,
    callback: spawnTreat,
    callbackScope: this,
    loop: true
  });
  
  // --- Set up score and message text ---
  scoreText = this.add.text(600, 10, 'Treats: 0', { fontSize: '20px', fill: '#000' });
  messageText = this.add.text(200, 80, 'Happy Birthday SOOBI!', { fontSize: '24px', fill: '#000' });
  messageText.visible = false;
  
  // --- Set up collisions ---
  this.physics.add.overlap(soobi, obstacles, hitObstacle, null, this);
  this.physics.add.overlap(soobi, treats, collectTreat, null, this);
  
  // --- Input: SPACE key and pointer (for mobile) trigger jump ---
  cursors = this.input.keyboard.createCursorKeys();
  this.input.on('pointerdown', jump, this);
}

function update() {
  if (gameOver) return;
  
  // No scrolling backgroundâ€”plain white sky with a ground line.
  
  // Jump with SPACE if Soobi is on the ground.
  if (cursors.space.isDown && soobi.body.touching.down) {
    jump.call(this);
  }
  
  // Move hurdles to the left.
  obstacles.children.iterate(function(child) {
    if (child) {
      child.x -= 4; // slower movement for an easy game
      if (child.x < -child.width) child.destroy();
    }
  });
  
  // Move treats to the left.
  treats.children.iterate(function(child) {
    if (child) {
      child.x -= 4;
      if (child.x < -child.width) child.destroy();
    }
  });
}

function jump() {
  if (soobi.body.touching.down) {
    soobi.setVelocityY(-500);
  }
}

function spawnObstacle() {
  // Create a hurdle obstacle using the generated texture.
  let obstacle = obstacles.create(800, 140, 'hurdle');
  obstacle.body.setAllowGravity(false);
  obstacle.setImmovable(true);
}

function spawnTreat() {
  // Spawn a treat (ðŸ— emoji) at a random vertical position (not overlapping obstacles).
  let treatY = Phaser.Math.Between(90, 130);
  let treat = this.add.text(800, treatY, 'ðŸ—', { fontSize: '24px', fill: '#000' });
  this.physics.add.existing(treat);
  treat.body.setAllowGravity(false);
  treat.setData('isTreat', true);
  treats.add(treat);
}

function hitObstacle(soobi, obstacle) {
  // When colliding with a hurdle, restart the game.
  gameOver = true;
  this.physics.pause();
  soobi.setTint(0xff0000);
  setTimeout(() => { 
    this.scene.restart();
    gameOver = false;
    score = 0;
  }, 1000);
}

function collectTreat(soobi, treat) {
  if (treat.getData('isTreat')) {
    treat.destroy();
    score++;
    scoreText.setText('Treats: ' + score);
    // End the game and celebrate after 50 treats are collected.
    if (score >= 50) {
      gameOver = true;
      messageText.visible = true;
      this.physics.pause();
      createConfetti.call(this);
    }
  }
}

function createConfetti() {
  // Create a particle emitter for confetti using the generated 'confetti' texture.
  let particles = this.add.particles('confetti');
  confettiEmitter = particles.createEmitter({
    x: { min: 0, max: 800 },
    y: 0,
    speedX: { min: -100, max: 100 },
    speedY: { min: 200, max: 400 },
    lifespan: 3000,
    quantity: 10,
    scale: { start: 1, end: 0 },
    blendMode: 'NORMAL',
    tint: [0x000000] // black confetti for a pure B&W feel
  });
  // Confetti falls indefinitely.
}
</script>
</body>
</html>
